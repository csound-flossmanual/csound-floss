# 01 Hello Csound

### What you learn in this tutorial

- How to create and output a **sine** tone.
- What Csound **opcodes** are.
- What **audio rate** in Csound means, and what an **audio variable** is.
- How we can draw a **signal flow**.
- What a Csound **instrument** is.
- What a Csound **score** is.



## What is a Sine Oscillator
A sine wave can be seen as the most elementary sound in the world.
When we draw a sine wave as a graph showing amplitude over time, 
it looks like this:

![Sine wave snake](../resources/images/01-GS-01-sine.png)

To produce a sine wave, Csound uses an oscillator.
An oscillator needs two informations as input:  

1. Which is the maximum amplitude to output. This results in louder or softer tones.  

2. How many periods (cycles) per second to create. This results in higher or
   lower pitches.  
   The unit is *Hertz (Hz)*. 1000 Hz would mean that a sine 
   has 1000 periods in each second.  


## A Sine Oscillator in Csound: Opcode and Arguments
Csound has many different oscillators.
(You can find [here](02-opcodes.md) some descriptions and comparisions.)

In this example, we use the opcode `poscil` which means "precise oscillator".  
An **opcode** is a processing unit in Csound, like an "object" in PureData or Max,
or a "UGen" in SuperCollider.  
If you are familiar with programming languages, you can see an opcode as a
built-in function.

The inputs of an opcode are called **arguments** and are written in parentheses
immediately after the opcode name.  
So `poscil(0.2,400)` means: The opcode `poscil` gets two input arguments.  
The first argument is the number `0.2`.  
The second argument is the number `400`.  
The meaning of the input arguments depends on how the opcode is implemented.
For `poscil`, the first input is the amplitude, and the second input is the
frequency. The [Csound Reference Manual](https://csound.com/docs/manual/index.html) 
contains the information about it.
We will give in [Tutorial 08](01-GS-08.md) some help how to use it.  
This way of writing code is very common in programming languages, like `range(13)` 
in [Python](https://en.wikipedia.org/wiki/Python_(programming_language)),
or `printf("no no")` in 
[C](https://en.wikipedia.org/wiki/C_(programming_language)), or `Date.now()` in
[JavaScript](https://en.wikipedia.org/wiki/JavaScript) (in the latter case with 
empty parentheses which means: no input arguments).

Note: There is also another way of writing Csound code. See 
[below](#traditional-and-functional-way-to-write-csound-code) 
if you want to learn more about it.  


## A Signal Flow and its Code
We create now a sine wave of 0.2 amplitude and 400 cycles per second (Hz).  
We will call this signal *aSine* because it is an audio signal. The character **a** 
at the beginning of the variable name signifies exactly this.  
An audio signal is a signal which produces a new value every sample.
(Learn more [here](16-a-digital-audio.md) about samples and sample rate.)  
This is the code line in Csound to produce the *aSine* signal:

    aSine = poscil:a(0.2,400)
	
This means: The signal *aSine* is created by the opcode `poscil` at audio rate
(`:a`), and the input for `poscil` is 0.2 for the amplitude and 400 for the 
frequency.

To output the signal (so that we can hear it), we put it in the `outall` 
opcode. This opcode sends an audio signal to all available output channels.

    outall(aSine)
	
Note that the signal *aSine* at first was the output of the oscillator, and 
then became input of the `outall` opcode. This is a typical chain which is 
well knows from modular synthesizers: A cable connects the output of one 
module with the input of another.

We can draw the program flow like this:

![Signal flow](../resources/images/01-GS-01-a.png){width=80%}

In the middle you see the signal flow, with symbols for the oscillator and 
the output. You can imagine this as modules of a synthesizer, connected by a 
cable called *aSine*.  
Left hand side you see the chain between input, opcode and output. Note that
the output of the first chain, contained in the *aSine* variable, becomes the
input of the second chain.  
Right hand side you see the Csound code. Each line of code represents one
*input -> opcode -> output* chain, in the form *output = opcode(input)*.
The line `outall(aSine)` does not have an output in Csound, because it sends 
audio to the hardware (similar to the "dac~" object in PD or Max).


## Your first Csound instrument
In Csound, all oscillators, filters, sample players and other processing units
are encapsulated in an **instrument**. An instrument has the keyword 
`instr` at its start, and `endin` at its end. 

After the keyword `instr`, seperated by a space, we assign a number (1, 2, 3, ...) or a 
name to the instrument. Let us call our instrument "Hello", and include the 
code which we discussed:


    instr Hello
      aSine = poscil:a(0.2,400)
      outall(aSine)
    endin


## Example

We are now ready to run the code. All we have to do is, to put the 
instrument in a complete Csound file.

Look at the code in the example. Can you retrieve the instrument code?

Push the "Play" button. You should hear two seconds of a 400 Hz sine tone.

Can you see why it plays for two seconds?

~~~csound
<CsoundSynthesizer>
<CsOptions>
-o dac
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs = 1

instr Hello
  aSine = poscil:a(0.2,400)
  outall(aSine)
endin

</CsInstruments>
<CsScore>
i "Hello" 0 2
</CsScore>
</CsoundSynthesizer>
~~~

## The Csound Score

At the bottom of the example code, you find this:


    <CsScore>
    i "Hello" 0 2
    </CsScore>
    

This is the **Score** section of the .csd File.
it starts with the tag `<CsScore>` and ends with `</CsScore>`.
In between there is this score line:

    i "Hello" 0 2
	
The `i` means: This is an instrument event.  
The `"Hello"` means: It is about the "Hello" instrument.  
The `0` means: Start time of this instrument is 0 (= start immediately).  
The `2` means: The duration of this instrument is 2 (seconds).
	

## Try it yourself
- Change the duration of the instrument.
- Change the start time of the instrument.
- Change the frequency of the oscillator.
- Change the amplitude of the oscillator.


## Opcodes, Keywords and Terms you have learned in this tutorial
### Opcodes
- `poscil:a(Amplitude,Frequency)` oscillator at audio rate, with amplitude
  and frequency input.
- `outall(aSignal)` outputs *aSignal* to all output channels.

### Keywords
- `instr ... endin` are the keywords to begin and end an instrument definition 

### Terms
- An *audio rate* or *a-rate* signal is a signal which is updated every sample.


## Go on now ...

with the next tutorial: [02 Hello Frequency](01-GS-02.md).


## ... or read some more explanations here

### Why is a sine "the most elementary sound in the world"?

To be honest, I like sine tones. I know that many people find them boring.
I like their simplicity, so against all good advices I will spend the first ten
Tutorials with sine tones. Sorry for being my victim to it ...

But back to the question: What is elementary at sine waves?

From a mathematical point of view it is quite fascinating that we can
understand and construct a sine as constant movement of a point on a circle.
Â´This is called "simple harmonic motion"
and is fundamental for many phenomena in the physical world, including sound.

For a musician, this is important to know:

- A sine tone is the only sound which represents only one frequency.  
- All other sounds have two or more frequencies in themselves.  
- These frequencies which are contained in one sound are called **partials**.  
- Each of these partials are sine tones, so a complex tone can be understood as
addition of sine waves. (More precise: A complex periodic sound.)

You can find more about this subject in the
[Additive Synthesis](04-a-additive-synthesis.md) chapter and in the
[Spectral Resynthesis](/sound-modification/fourier-analysis-spectral-processing)
chapter of this book.


### Traditional and functional way to write Csound code

Perhaps you are surprised to see Csound code written in the way it is described 
above. In fact, the classical way to write Csound code was like this:

~~~csound
aSine poscil 0.2, 400
      outall aSine
~~~

You are welcome to continue writing code in this way. The reasons why I use the
"functional" way of writing Csound code in these Tutorials are:

1. We are all familiar with this way to declare a left hand side variable `y`
to be the sum of another variable `x` plus two:  
`y = x + 2`  
Or, a bit more mathematically:  
`y = f(x)`  
It is good to use this familiarity. It is hard to learn a programming language,
in particular when you are musician and have never heard about variables,
signal flow, audio variables, or parameters. What ever let you feel more 
familiar in this new world is helpful and should be used.

2. As mentioned above, most other programming languages use a similar syntax,
in the form *output = function(arguments)*. So for people who already know any
other programming language, it helps learning Csound.

3. The functional style of writing Csound code has always been there in 
expressions like `ampdb(-10)` or `ftlen(giTable)`. So it is somehow not 
completely new but an extension.

4. Whenever we want to use an expression as argument (you will learn more about
it in [Tutorial 06](01-GS-06.md)) we need this way of writing code. So it is good
to use it as consistent as possible.


### About these tutorials

This *Getting Started* has been written by Joachim Heintz in 2023. It is based
on many experiences in teaching Csound to young composers. 
Thanks goes to all students and friends,
from Hanover University of Music, from Yarava Music Group Tehran, and elsewhere,
who gave me feedback and contributed in one or another way to this and other
texts and contents. Amin and Parham, Marijana and Betty, Tom and Farhad, Ehsan 
and Vincent, Julio and Arsalan, to name some of them.

Other thanks go to ...

And of course to the Core Developers whose great work made it possible that we
all can use Csound in the way we do. 
I hope this Tutorial can show to some more musicians how
admirable and successful the big effort has been to turn the oldest audio
programming language into a modern one, without losing any old piece of code.

Each Tutorial has a first part as *must read* (well which *must* is that),
followed by an optional part 
(in which of course the most interesting things reside). To make at least one 
thing in the world reliable, each *must read* consists of five heading, and each
*can read* of three. Actually I planned it to be 4+3, but then I asked Csound,
and received this answer:

    if 4+3 == 7 then
      "Write this Tutorial!\n"
    else
      8!
    endif

So I took this as oracle and decided for 5+3 headings, to fulfill also the `8!`
requirement. It is always better to satisfy both gods of a conditional branch,
in my experience.

Included in the *must read* part is a *must do*. At first a central example,
yes very central, substantial, expedient, enjoyable, and of course very 
instructive. And then a *Try it yourself* which is kind of the dark side of 
the example: As easy it is to just push the "Run" button, as hard can it
perhaps be to solve these damned exercises. But, to quote John ffitch:
"We have all been there ..."

This *Getting Started* is supposed to be one amongst many. Its focus is on
learning the language: How to think and to program in Csound. I believe that
who understands it, and enjoys Csound's simplicity and clarity, has all doors
open to go anywhere, and learn about exquisit sounds and the infinite possibilities
in Csound to create and shape them. Iain McCurdy's examples, on his 
[website](http://iainmccurdy.org/csound.html)
or inside [Cabbage](https://cabbageaudio.com/)
are an inexhaustible source, amongst others.
