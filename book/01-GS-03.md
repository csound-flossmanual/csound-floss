# 03 Hello Amplitude


## What you learn in this tutorial

- What "orchestra header constants" in Csound are


## A line for the amplitude

Once we understood how to create lines, we can apply 
a linear movement to the amplitude, too. 

This is a signal which moves from 0.3 to 0.1 in half a second:

![Amplitude decay](../resources/images/01-GS-03-a.png)

And this code will already look quite familiar to you:

    kAmp = linseg:k(0.3,0.5,0.1)


Note: Acoustically this way to change volume is questionable.
We will discuss this in Tutorial 05.

## Back to the head

Let us now look at some important settings which are written on top of the
`<CsInstruments>` tag:

    sr = 44100
    ksmps = 64
    nchnls = 2
    0dbfs = 1

This is sometimes called the "Orchestra Header".

We see four constants which should be written in every Csound file.  

They are called "constants" because you cannot change them during one run of 
Csound.  
Once you start Csound (by pushing the "Play" button), and Csound compiles, these
values remain as they are, until you stop.

What do these constants mean?

### sr

**sr** means **sample rate**. This is the number of audio samples per one second.
Common values are 44100 (the CD standard), 48000 (video standard), or higher 
values like 96000 or 192000.

As the sample rate is measured per second, it is often given in Hertz (Hz),
or kilo Hertz (kHz).

You should choose the sample rate which fits to your needs.  
When you produce audio for an *mpeg* video which needs 48 kHz, you should set:

    sr = 48000
    
When your sound card runs at 44100 Hz, you should set your `sr` to the same
value (or vice versa).

### ksmps

**ksmps** means **number of samples in one control period**.

As we explained in Tutorial 02, the *k-rate* is based on the sample rate.
A group or block of samples is put together in a package. Imagine yourself 
standing besides a belt, and little cubes arrive on the belt in a regular
time interval, say once a second. Rather than taking each cube, and throwing 
it to a collegue, you collect 64 of the cubes in one package. A collegue throws 
this package once the 64 cubes are completed. If you are a really good team,
the collegue will throw one package every 64 seconds.

This "time to throw a package" is the k-rate. In our example, it is 64 times
slower than the rate in which the little cubes arrive. When we imagine the
cubes as samples, the k-rate is in this example 64 times slower than the
sample rate.

The **ksmps** constant defines how many samples are collected for one 
package.  
What we called "package" here, is in technical terms called "block" or 
"vector" or "audio vector".  
So *ksmsps* is exactly the same as "block size" in PureData or "vector size"
in Max.

### nchnls

**nchnls** means **number of channels**. When you have a stereo sound card,
you will set `nchnls = 2`.

When you use eight speakers, you must set `nchnls = 8`. You will need a sound
card with at least eight channels the for real-time output.

### 0dbfs

**0dbfs** means **what is the amplitude which represents 0 dB full scale**.

This sounds a bit more complicated as it is.

We define here a number which is regarded as maximum amplitude.

We should always set this number to 1, as this is what all audio applications
do. 0 is minimum amplitude (meaning "silence"), and 1 is maximum amplitude.

Always set

    0dbfs = 1
    
and you will be fine.

(We will explain more in Tutorial 05 about dB.)


## Example

Look how both, the *kAmp* and *kFreq* line, are created by the `linseg` opcode.

These two lines are fed via the variable names into the `poscil` oscillator.

~~~csound
<CsoundSynthesizer>
<CsOptions>
-o dac
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs = 1

instr Hello
  kAmp = linseg:k(0.3,0.5,0.1)
  kFreq = linseg:k(500,0.5,400)
  aSine = poscil:a(kAmp,kFreq)
  outall(aSine)
endin

</CsInstruments>
<CsScore>
i "Hello" 0 2
</CsScore>
</CsoundSynthesizer>
~~~
 

## Try it yourself

- Change the duration in the *kAmp* signal from 0.5 to 1 or 2. The frequency
and the amplitude line are now moving independently from each other.
- Change the values of the *kAmp* signal so that you get a rising rather than a 
decaying amplitude.
- Change `0dbfs` to 2. You should hear that it sounds softer now because the
"full scale" level is twice as high.
- Change `0dbfs`to 0.5. You should hear that it sounds louder now because the
"full scale" level is set to 0.5 now instead of 1.
- Move the line `aSine = poscil:a(kAmp,kFreq)` from third position in the
instrument to the first position. Push the "Play" button and look at the 
error message. Can you understand why Csound is complaining?


## Constants and Terms you have learned in this tutorial

### Constants
- `sr` number of samples per second
- `ksmps` number of samples in one control block
- `nchnls` number of channels
- `0dbfs` number (amplitude) for zero dB full scale

### Terms
- *audio vector size* or *block size* is what Csound sets as `ksmps`:
the number of samples in one control cycle


## Go on now ...

with the next tutorial: [04 Hello MIDI Keys](01-GS-04.md).


## ... or read some more explanations here

### Some notes about ksmps

Note 1: It is recommended to use "power-of-two" values for `ksmps`.
Common values are 32 (= $2^5$) or 64 (= $2^6$).

Note 2: The advantage of a smaller `ksmps` is the better time resolution for
the control rate.  
If the sample rate is 44100 Hz, we have a time resolution of 1/44100 seconds 
for each sample. This is about 0.000023 seconds or 0.023 milliseconds.  
If we set `ksmps = 64` for this sample rate, we get 64/44100 seconds as time
resolution for each control value. This is about 0.00145 seconds or 1.45
milliseconds.  
If we set `ksmps = 32` for the same sample rate, we get 0.725 milliseconds
as time resolution for each new control value.

Note 3: The advantage of a larger `ksmps` is the better performance in terms
of speed. If you have a complex and CPU consuming Csound file, and get dropouts,
you can try to increase `ksmps`.

Note 4: Although `ksmps`is a constant, we can set a "local ksmps" in one 
instrument. The opcode for this operation is `setksmps`.  
Sometimes we wish to run a krate opcode in one instrument sample by sample.
In this case, we can use `setksmps(1)`.  
We only can split the global `ksmps` into smaller parts, not vice versa.


### Signal flow and order of execution
